# آشنایی با اصول شئ‌گرایی (موسوم به اصول SOLID)

---
### گام ۱: افزودن یک روش پیام رسانی دیگر

| ردیف | نام کلاس                          | نوع تغییر     | شرح تغییر                                                           |
| ---- | --------------------------------- | ------------- | ------------------------------------------------------------------- |
| 1    | `PaymentProcessor`                | افزودن متد    | اضافه کردن متد جدید `payOnSite(double amount)` برای پرداخت حضوری    |
| 2    | `ReservationService`              | افزودن شرط    | اضافه کردن case جدید `ONSITE` در switch statement برای پرداخت حضوری |
| 3    | ```interface MessageSender```<br> | تغییر نام متد | تغییر نام متد ```SendEmail``` به `SendMessage`                      |
| 4    | EmailSender                       | افزودن کلاس   | ایجاد کلاس `EmailSender` برای ارسال پیام با ایمیل                   |


### گام 2: تحلیل اصول شی گرایی


<table dir='rtl'>
<tbody>
<tr>
<td>
<p>اصل</p>
</td>
<td>
<p>برقراری/نقض</p>
</td>
<td>
<p>علت</p>
</td>
</tr>
<tr>
<td rowspan="2" width="240">
<p>Single Responsibility</p>
</td>
<td width="95">
<p><strong>موارد تحقق</strong></p>
</td>
<td width="454">
<p>در کلاس Room و Customer این اصل برقرار است.</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>در کلاس LuxuryRoom.java اصل Single Responsibility توسط متد addFreeDinner نقض شده است. این متد باید در یک کلاس جداگانه تحت عنوان سرویس های اتاق لاکچری تعریف شود.</p>
<p>در کلاس PaymentProcessor.java پنج متد پرداخت تعریف شده است که با اصل Single Responsibility در تناقض است. بر طبق این اصل هر کدام از این متد ها باید در کلاس مربوط به خودشان پیاده سازی شود. </p>
<p>در کلاس Reservation.java نیز وجود متد totalPrice نیز این اصل را زیر سوال میبرد.</p>
<p>مهم تر از همه در کلاس ReservationService.java یک کلاس برای ایجاد یک رزرو اقدام به محاسبه تخفیف، انتخاب روش پرداخت و درنهایت انتخاب روش اطلاع رسانی میکند. تمامی این موارد این اصل را نقض میکند. </p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>Open-Close Principle (OCP)</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>-</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>در کلاس PaymentProcessor برای ایجاد یک روش جدید پرداخت مجبور به تغییر کل کلاس شدیم که اصل open close را زیر سوال سوال میبرد. </p>
<p>در اینترفیس MessageSender یک متد با نام SendEmail وجود دارد که این امر امکان اضافه کردن دیگر روش های ارسال پیام بدون تغییر در خود اینترفیس را ناممکن میسازد.</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>Liskov Substitution Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>کلاس LuxuryRoom از کلاس Room ارث بری میکند که در کلاس Main.java دقیقا در جایی که انتظار کلاس Room را داریم توانستیم از کلاس LuxuryRoom استفاده کنیم.</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>-</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>Interface Segregation Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>-</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>در اینترفیس MessageSender اگر بدون تغییر نام متد SendEmail بخواهیم یک روش جدید پیامرسانی اضافه کنیم، مجبوریم یک متدی را که از ان استفاده ای نمیکنیم را پیاده سازی کرده و در بدنه آن، یک خطا برگردانیم. که با این اصل در تناقص است.</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>Dependency Inversion Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>-</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>در کلاس ReservationsService در دو قسمت این اصل نقض شده است. یک: در بخش انتخاب روش پرداخت و دو در انتخاب روش پیام رسانی. برای ما نباید مهم باشد که کاربر از چه روشی پرداخت میکند یا با چه روشی پیام ها را دریافت میکند. اما در اینجا با ایجاد یک switch case خودمان را درگیر جزئیات پیاده سازی کرده ایم. </p>
</td>
</tr>
<tr>
<td rowspan="2" width="240">
<p>Composite Reuse Principle</p>
</td>
<td width="95">
<p><strong>موارد تحقق</strong></p>
</td>
<td width="454">
<p>موردی متناسب با این موضوع پیدا نشد.</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>-</p>
</td>
</tr>
<tr>
<td rowspan="2" width="240">
<p>Principle of Least Knowledge</p>
</td>
<td width="95">
<p><strong>موارد تحقق</strong></p>
</td>
<td width="454">
<p>-</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>در کلاس ReservationService برای بدست آوردن بعضی از مقادیر، مجبور شدیم چندین مرحله به اتریبیوت های اشیا دسترسی پیدا کنیم. به طور کلی ما اجازه عمیق شدن بیش از یک مرحه در اتریبیوت های اشیایی که در اختیار داریم را، نداریم. به عنوان مثال در switch انتخاب روش پیام رسانی از این کد استفاده شده است : <strong>res.customer.mobile</strong> که این اصل را نقض میکند</p>
</td>
</tr>
</tbody>
</table>

### گام 3: اصلاح موارد نقض

- برای رفع مشکلات SRP در ReservationService و OCP و DIP از دیزاین پترن فکتوری برای پیاده سازی SendMessage و PaymentMethod استفاده کردیم و در ReservationService تنها از Interface های آنها استفاده کردیم.
- همچنین متد addFreeDinner در کلاس LuxuryRoom را به یک سرویس جداگانه منتقل کردیم تا اصل SRP برقرار شود.
- همچنین دو سرویس جداگانه برای چاپ صورت حساب و محاسبه تخفیف بر اساس شهر ایجاد کردیم.
- برای رفع مشکل PLK پراپرتی های کلاس ها را به صورت private تعریف کرده و متد های getter و setter را نیز برای دسترسی به مقادیر انها تعریف کردیم.
- برای رفع مشکل ISP نام متد SendEmail در اینترفیس MessageSender را به SendMessage تغییر دادیم.
### گام 4: ارزیابی

- اگر از ابتدا این اصول رعایت میشد، بسیاری از تغییرات داده شده از جمله دیزاین پترن فکتوری و سرویس های جداگانه و تغییر نام های متد حذف میشدند زیرا از قبل به صورت اصولی پیاده سازی شده بودند.
- و برای ایجاد دو قابلیت جدید در گام اول، صرفا دو کلاس SmsSender و PayOnSite اضافه می‌کردیم و هیچ تغییر اضافی لازم نبود.

### گام 5: نتیجه گیری

- با رعایت اصول شی‌گرایی، نگهداری و توسعه پروژه در آینده بسیار ساده تر و سریعتر میشود. در صورت کار گروهی بر روی پروژه نیز، با احتمال کمتری به conflict برخورد میکنیم.
- بنابراین این اصول بر روی سرعت توسعه، آسانی نگهداری و کار تیمی تاثیر مثبت دارند.